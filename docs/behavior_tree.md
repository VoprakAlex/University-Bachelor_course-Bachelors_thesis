
# Поведенческие деревья

## Определение

Поведенческое дерево — это, прежде всего, вычислительная модель, представленная в виде ориентированного ациклического графа, где корневой узел связывает через древовидную структуру все остальные компоненты. Эта модель имеет строго заданную семантику выполнения, что делает поведение агента детерминированным и предсказуемым при отладке.

Основная цель поведенческого дерева — декомпозиция высокой-level цели на последовательность более простых, вплоть до элементарных задач. Сложное поведение, такое как "Охранять территорию", разбивается на подцели ("Патрулировать", "Атаковать врага"), которые, в свою очередь, могут быть разбиты далее ("Обойти точку А", "Обойти точку Б", "Проверить шум").

Поведенческое дерево строится из набора стандартизированных узлов, каждый из которых выполняет строго определенную функцию. Эта модульность позволяет:

* Повторно использовать отдельные ветви дерева (поддеревья) в разных контекстах и у разных агентов.
* Легко модифицировать поведение, добавляя, удаляя или переставляя узлы, без необходимости переписывать всю систему.
* Компоновать сложные поведения из простых, проверенных блоков.

**Классификация узлов по функциональности:**

* **Контрольные узлы** управляют потоком выполнения и определяют порядок обхода дочерних узлов. К ним относятся:

  * **Последовательность:** Выполняет дочерние узлы по порядку, пока все не завершатся успешно. При первой же неудаче выполнение прерывается.
  * **Селектор:** Выполняет дочерние узлы по порядку, пока один из них не завершится успешно или не вернет статус "Выполняется". Это реализует логику выбора первой работоспособной стратегии.

* **Исполнительные узлы** являются листьями дерева и непосредственно взаимодействуют с моделью мира или выполняют действия:

  * **Действие:** Изменяет состояние мира (например, "открыть дверь").
  * **Условие:** Проверяет факт о состоянии мира (например, "дверь закрыта?"), не изменяя его.

* **Декораторы** модифицируют поведение или результат своего единственного дочернего узла (например, инвертируют его результат, ограничивают по времени, зацикливают).

## История

### Предпосылки и Период до Формализации (до 2002 г.)

1. **Доминирование конечных автоматов (FSM):** ИИ в играх долгое время базировался на конечных автоматах. Простые FSM хорошо подходили для линейного поведения (например, "патруль -> атака -> преследование"), но с ростом сложности NPC они становились громоздкими, трудночитаемыми и неподдерживаемыми. Возникали так называемые "лапша из переходов" (spaghetti transitions), когда добавление нового состояния требовало создания множества новых связей, что делало код хрупким и негибким.

2. **Появление иерархических конечных автоматов (HFSM):** Для борьбы со сложностью FSM был предложен подход HFSM, где состояния могли сами содержать вложенные автоматы. Это улучшило структуризацию, но не решило проблему полностью. Модульность и повторное использование кода оставались низкими, так как переходы между состояниями были жёстко закодированы.

3. **Влияние робототехники и ИИ:**
    * В академической среде, особенно в робототехнике, развивались такие архитектуры, как субсумционная архитектура Родни Брукса, которая предлагала поведенческий подход, где простые модули поведения (например, "избегай препятствий", "иди к цели") конкурировали за контроль над роботом. Это повлияло на философию декомпозиции поведения.
    * **Деревья задач (Task Trees)** и **HTN-планирование (Hierarchical Task Network)** также предоставили модели для иерархического представления целей и подцелей.

### Зарождение и Формализация в Игровой Индустрии (~2002-2005 гг.)

Ключевой фигурой в истории поведенческих деревьев считается *Дамиан Исла*, который впервые представил и формально описал эту архитектуру в контексте разработки ИИ для игры Halo 2.

* **Проблема:** Команде разработчиков Halo 2 требовалось создать сложное, реактивное и правдоподобное поведение для персонажей "Ковенантов", которое было бы легко создавать, тестировать и изменять дизайнерам, не являющимся программистами.
* **Решение:** Исла и его коллеги разработали то, что они изначально называли "диспетчером задач" (Task Manager), который эволюционировал в формальную модель поведенческого дерева. Они осознали, что древовидная структура с чётко определёнными узлами (Последовательность, Селектор) и тремя состояниями (Успех, Неудача, Выполняется) идеально подходит для их нужд.
* **Публикация:** Свои идеи Дамиан Исла представил в 2005 году на конференции Game Developers Conference (GDC) в докладе "Managing Complexity in the Halo 2 AI System". Этот доклад стал отправной точкой для широкого распространения технологии в игровой индустрии. В нём были четко обозначены преимущества BT над FSM: модульность, возможность "вставки" новых поведений в дерево без переписывания существующей логики, и лучшая визуализация.

### Распространение и Стандартизация (~2005-2010 гг.)

После успеха Halo 2, поведенческие деревья быстро завоевали популярность среди ведущих студий-разработчиков игр.

* **BioWare** активно использовала их в таких играх, как серия **Mass Effect** и **Dragon Age**.
* **Crytek** интегрировала BT в движок CryEngine для игры **Crysis**.
* Другие крупные компании, такие как **Epic Games** (в Unreal Engine) и студии, работающие с **Unity**, начали либо разрабатывать собственные реализации, либо использовать сторонние плагины.

В этот период сформировался "классический" набор узлов (Sequence, Selector/Fallback, Decorator, Action, Condition) и устоялась семантика их выполнения. Появились первые визуальные редакторы BT, которые позволили геймдизайнерам напрямую работать с логикой ИИ, не написания кода, что было одним из ключевых преимуществ технологии.

### Академическое Признание и Развитие в Робототехнике (~2010 - по настоящее время)

Изначально рождённая в индустрии, технология со временем привлекла внимание академического сообщества.

* **Формальное моделирование:** Учёные начали описывать BT с помощью формальных методов, таких как **теория автоматов**, **временная логика** и **анализ устойчивости**. Это позволило математически доказывать корректность поведения деревьев.
* **Ключевые исследования:** Работы таких исследователей, как Мишель Колледанкизе и Петтер Ёгрен из Королевского технологического института (KTH, Швеция), сыграли важную роль в формализации BT. Они показали, как поведенческие деревья связаны с гибридными системами управления и как их можно использовать для обеспечения таких свойств, как реактивность и отказоустойчивость в робототехнике.
* **Сближение с другими методами ИИ:** Началось активное исследование по комбинированию BT с другими парадигмами:
  * **Планирование:** BT стали использоваться как средство для исполнения планов, сгенерированных HTN-планировщиками или другими системами.
  * **Машинное обучение:** Появились подходы к автоматическому обучению и оптимизации структуры BT с помощью методов обучения с подкреплением (Reinforcement Learning).

### Современное состояние

На сегодняшний день поведенческие деревья являются де-факто стандартом для создания неигровых персонажей во многих игровых движках и сложных автономных систем в робототехнике. Они эволюционировали от простой альтернативы FSM до зрелой, хорошо формализованной технологии, поддерживающей такие возможности, как параллельное выполнение, работа с черными досками (Blackboard) для обмена данными и динамическая перепланировка.

## Принцип работы: механизм тиков и состояний

**Цикл выполнения (Tick):**

Работа дерева активируется периодическими сигналами (тиками), которые исходят от корневого узла. Тики передаются от родительских узлов к дочерним по определённым правилам.Каждый узел в дереве в ответ на тик должен вернуть одно из трёх состояний:

* **Успех (Success):** Задача узла успешно выполнена.
* **Неудача (Failure):** Задача узла не может быть выполнена в текущих условиях.
* **Выполняется (Running):** Задача начата, но ещё не завершена; для её завершения требуются последующие тики. Этот статус принципиально важен для реализации длительных по времени действий.

**Обработка состояний:** Логика работы дерева определяется тем, как родительские узлы обрабатывают состояния, возвращаемые их дочерними узлами. Разные типы узлов по-разному реагируют на `Success` и `Failure`, что и порождает сложное поведение.

### Ключевые моменты работы узлов

#### 1. Контрольные узлы (Управление потоком выполнения)

* **Последовательность (Sequence):**
**Как работает:** Последовательно, слева направо, отправляет тик каждому дочернему узлу.
**Смысл:** Реализует логику "И" — все шаги в последовательности должны быть выполнены.
**Ключевая логика:**
  * Если дочерний узел возвращает **Success**, последовательность переходит к следующему дочернему узлу.
  * Если дочерний узел возвращает **Failure**, последовательность немедленно прерывается и возвращает **Failure**.
  * Если дочерний узел возвращает **Running**, последовательность приостанавливается и возвращает **Running**. На следующем тике она продолжит с этого же узла.
  * **Success** возвращается только тогда, когда *все* дочерние узлы вернули Success.

* **Селектор (Selector / Fallback):**
**Как работает:** Последовательно, слева направо, отправляет тик каждому дочернему узлу.
**Смысл:** Реализует логику "ИЛИ" — выполняется первая дочерняя задача, которая может быть выполнена. Это основа для построения систем приоритетов.
**Ключевая логика:**
  * Если дочерний узел возвращает **Failure**, селектор переходит к следующему дочернему узлу.
  * Если дочерний узел возвращает **Success**, селектор немедленно прерывается и возвращает **Success**.
  * Если дочерний узел возвращает **Running**, селектор приостанавливается и возвращает **Running**.
  * **Failure** возвращается только тогда, когда *все* дочерние узлы вернули Failure.

#### 2. Исполнительные узлы (Взаимодействие с миром)

* **Действие (Action):**
**Как работает:** Содержит код, который непосредственно воздействует на среду (начать анимацию, вычислить путь, применить лечение).
**Ключевая логика:** Может вернуть любое из трёх состояний. Например, действие "Идти к точке" будет возвращать `Running`, пока персонаж в пути, `Success` — когда точка достигнута, и `Failure` — если путь невозможен.

* **Условие (Condition):**
**Как работает:** Проверяет факт в модели мира (например, проверяет значение переменной, расстояние до объекта).
**Ключевая логика:** Всегда возвращает **Success** (если условие истинно) или **Failure** (если ложно). Никогда не возвращает `Running`, так как не выполняет действий, а лишь производит мгновенную проверку.

#### 3. Декораторы (Модификация поведения)

**Как работает:** Декоратор имеет ровно одного дочернего узла и изменяет его поведение или результат.
**Ключевые примеры:**

* **Инвертор (Inverter):** Меняет местами статусы `Success` и `Failure` у дочернего узла.
* **Повторитель (Repeater):** Многократно перезапускает дочерний узел, пока не сработает условие остановки.
* **До успеха (Until Success):** Постоянно перезапускает дочерний узел, пока тот не вернёт `Success`.

### Ключевые архитектурные моменты технологии

**Реактивность:** Дерево переоценивается на каждом тике. Это означает, что если во время выполнения длительной операции (`Running`) изменится состояние мира (например, появится враг), на следующем тике селектор на более высоком уровне может переключиться на более приоритетную ветку, прервав текущую. Это делает агента чрезвычайно отзывчивым к изменениям в среде.

**Модульность и иерархичность:** Любая ветка дерева может быть сохранена как отдельное поддерево и использована в другом месте. Это позволяет создавать библиотеки типовых поведений (например, "Патрулировать по точкам", "Укрыться от огня") и комбинировать их в более сложные деревья.

**Разделение данных: Blackboard ("Доска")**

* Для обмена информацией между узлами (например, между условием "Враг в поле зрения?" и действием "Атаковать врага") используется общая структура данных, называемая "Blackboard".
* Это ключевой момент для обеспечения гибкости: узлы не связаны жёстко друг с другом, а общаются через чтение и запись параметров в этой общей области памяти.

**Удобство отладки и визуализации:** Поскольку структура дерева статична, его текущее состояние легко визуализировать. Можно подсвечивать активные в данный момент узлы (возвращающие `Running`), что даёт чёткое представление о том, какую именно ветку поведения исполняет агент и почему он принял то или иное решение.

## Где используется

### 1. Компьютерные игры

Наиболее распространенная и исторически первая область применения поведенческих деревьев.

**Управление неигровыми персонажами (NPC):** Создание правдоподобного поведения врагов, союзников, нейтральных персонажей и гражданских лиц. Например:

* **Поведение врагов:** Патрулирование, преследование игрока, укрытие от огня, использование тактик окружения, призыв подкрепления.
* **Поведение союзников:** Следование за игроком, прикрытие огнем, лечение, выполнение приказов.
* **Система диалогов:** Управление сложными ветвями диалогов, где выбор реплики зависит от множества условий (репутация, пройденные квесты, раса).
* **Управление боссами:** Организация сложных многофазных сражений с боссами, где каждая фаза представляет собой отдельную ветвь дерева (атака в ближнем бою, переход на дальнюю дистанцию, призыв миньонов, использование особых способностей).
* **Система искусственного интеллекта партнеров:** Например, в играх с кооперативным прохождением, где ИИ управляет напарником игрока.
* **Динамическое управление сценарными событиями:** Координация действий нескольких NPC для создания сложных скриптовых сцен.

### 2. Робототехника

Поведенческие деревья идеально подходят для организации высокоуровневого управления задачами роботов благодаря своей иерархичности и реактивности.

* **Мобильная робототехника:** Навигация и выполнение задач автономными мобильными роботами (логистические роботы на складах, роботы-уборщики, роботы-гиды).
* **Манипуляционная робототехника:** Управление роботами-манипуляторами для выполнения сложных операций (сборка, сортировка, упаковка).
* **Автономные летательные аппараты (дроны):** Выполнение миссий, таких как картография, мониторинг объектов, поиск и следование за целью.
* **Социальные и сервисные роботы:** Организация взаимодействия с людьми, где требуется чередование различных моделей поведения в зависимости от действий человека.

### 3. Моделирование и виртуальные миры

Использование для создания реалистичного поведения большого количества агентов в симуляциях.

* **Гражданские в играх и симуляторах:** Моделирование повседневной жизни горожан в градостроительных симуляторах (Cities: Skylines) или играх (серия The Sims).
* **Военные симуляторы:** Моделирование тактики и поведения подразделений в тренировочных симуляторах.
* **Транспортные симуляторы:** Управление логистикой и поведением транспортных средств в сложных системах.

### 4. Автономные системы и Интернет вещей (IoT)

Применение для управления сложными, распределенными системами, которые должны адаптироваться к изменяющимся условиям.

* **Умный дом:** Координация работы различных устройств (освещение, отопление, безопасность) на основе комплексных условий (время суток, присутствие людей, погода).
* **Промышленная автоматизация:** Управление технологическими процессами, где операции должны выполняться в строгой последовательности, но с возможностью реакции на аварийные ситуации (остановка конвейера при обнаружении брака).
* **Управление беспилотными автомобилями:** Высокоуровневое планирование маршрута и принятие решений (перестроение, объезд препятствия, парковка). Хотя здесь поведенческие деревья часто комбинируются с другими, более сложными системами планирования.

### 5. Образовательные и исследовательские проекты

* **Обучение основам ИИ:** Поведенческие деревья являются наглядным и понятным инструментом для преподавания принципов планирования и принятия решений в искусственном интеллекте.
* **Прототипирование:** Быстрое создание прототипов сложного поведения для научных исследований, например, в области поведенческой экологии (моделирование поведения стаи животных) или когнитивных наук.

### Критерии целесообразности применения технологии

Поведенческие деревья наиболее эффективны в системах, для которых характерны:

* **Высокая степень иерархичности задач:** Цель может быть разбита на подцели.
* **Необходимость модульности и повторного использования:** Компоненты поведения используются в разных контекстах.
* **Реактивность:** Требуется частое перепланирование и реакция на изменения внешней среды.
* **Визуализация и удобство отладки:** Важна возможность наглядного представления логики работы системы для дизайнеров и тестировщиков.
